#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform CameraBufferObject {
    mat4 view;
    mat4 proj;
} camera;

layout(set = 1, binding = 0) uniform Time {
    vec4 timeData; 
    vec4 spherePosition;
    vec4 cullingFlags; // x=orientation, y=frustum, z=distance, w=unused
};

struct Blade {
    vec4 v0;
    vec4 v1;
    vec4 v2;
    vec4 up;
};

// Input blades
layout(set = 2, binding = 0) buffer Blades {
    Blade blades[];
};

// Output culled blades
layout(set = 2, binding = 1) buffer CulledBlades {
    Blade culledBlades[];
};

// Indirect draw parameters
layout(set = 2, binding = 2) buffer NumBlades {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
} numBlades;

bool inBounds(float value, float bounds) {
    return (value >= -bounds) && (value <= bounds);
}

// Simple smooth noise functions
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

float snoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                       -0.577350269189626, 0.024390243902439);
    vec2 i  = floor(v + dot(v, C.yy));
    vec2 x0 = v - i + dot(i, C.xx);
    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod289(i);
    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                            + i.x + vec3(0.0, i1.x, 1.0));
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m;
    m = m*m;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

void main() {
    // Reset the number of blades to 0
    if (gl_GlobalInvocationID.x == 0) {
        numBlades.vertexCount = 0;
    }
    barrier();

    uint index = gl_GlobalInvocationID.x;
    
    if (index >= blades.length()) {
        return;
    }

    Blade blade = blades[index];
    
    // Extract blade properties
    vec3 v0 = blade.v0.xyz;
    vec3 v1 = blade.v1.xyz;
    vec3 v2 = blade.v2.xyz;
    vec3 up = blade.up.xyz;
    
    float orientation = blade.v0.w;
    float height = blade.v1.w;
    float width = blade.v2.w;
    float stiffness = blade.up.w;

    // === FORCES ===
    
    // Gravity
    vec3 gE = normalize(vec3(0.0, -1.0, 0.0)) * 9.8;
    vec3 front = normalize(cross(up, vec3(sin(orientation), 0.0, cos(orientation))));
    vec3 gF = 0.25 * length(gE) * front;
    vec3 g = gE + gF;
    
    // Recovery
    vec3 iv2 = v0 + up * height;
    vec3 r = (iv2 - v2) * stiffness;
    
    // === FASTER & STRONGER WIND ===
    
    float time = timeData.y;
    
    // Simple overlapping sine waves for smooth, natural movement
    vec2 windPos = v0.xz * 0.05;
    
    // Primary wind wave (faster now)
    float wind1 = sin(time * 0.6 + windPos.x * 0.3) * cos(time * 0.5 + windPos.y * 0.2);
    
    // Secondary wave (adds variation)
    float wind2 = sin(time * 0.9 + windPos.x * 0.5 + windPos.y * 0.4) * 0.5;
    
    // Add some noise for natural irregularity
    float windNoise = snoise(windPos * 2.0 + vec2(time * 0.35, time * 0.25)) * 0.4;
    
    // Combine for stronger wind
    float windStrength = 7.0 + (wind1 + wind2 + windNoise) * 4.5;
    
    // Faster changing wind direction
    float windAngle = time * 0.25 + sin(time * 0.15) * 0.7;
    vec3 windDirection = normalize(vec3(cos(windAngle), 0.0, sin(windAngle)));
    
    // More frequent gusts
    float gustWave = sin(time * 0.4 + windPos.x * 0.2);
    float gust = smoothstep(0.6, 1.0, gustWave) * 5.0;
    
    vec3 windForce = windDirection * (windStrength + gust);
    
    // Wind alignment
    vec3 bladeDir = normalize(v2 - v0);
    float alignment = dot(normalize(windDirection), bladeDir);
    float fd = 1.0 - abs(alignment);
    
    // Apply wind
    vec3 w = windForce * fd;
    
    // === SPHERE INTERACTION ===
    vec3 sphereRepulsion = vec3(0.0);
    vec3 sphereCenter = spherePosition.xyz;
    float sphereRadius = spherePosition.w;

    float distToSphere = length(v0 - sphereCenter);
    float interactionRadius = sphereRadius + 3.0;
    
    if (distToSphere < interactionRadius) {
        vec3 repulsionDir = normalize(v0 - sphereCenter);
        float strength = 1.0 - (distToSphere / interactionRadius);
        strength = strength * strength;
        sphereRepulsion = repulsionDir * 15.0 * strength;
    }

    // Total force
    vec3 tv2 = (g + r + w + sphereRepulsion) * timeData.x;

    // Update v2
    vec3 v2_new = v2 + tv2;
    
    // === STATE VALIDATION ===
    
    // Make sure v2 doesn't go below ground
    v2_new = v2_new - up * min(dot(up, v2_new - v0), 0.0);
    
    // Maintain blade length
    float lproj = length(v2_new - v0 - up * dot(v2_new - v0, up));
    v2_new = v0 + up * height + normalize(v2_new - v0 - up * dot(v2_new - v0, up)) * min(lproj, height);
    
    // Update v1 (Bezier point)
    vec3 v1_new = v0 + height * up * 0.5 + (v2_new - v0 - height * up) * 0.5;
    
    // Update blade
    blade.v1.xyz = v1_new;
    blade.v2.xyz = v2_new;
    
    // === CULLING ===
    
    bool visible = true;
    
    // 1. Orientation culling
    if (cullingFlags.x > 0.5) {
        vec3 camPos = (inverse(camera.view) * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
        vec3 viewDir = normalize(camPos - v0);
        vec3 front = normalize(cross(up, vec3(sin(orientation), 0.0, cos(orientation))));
        
        // Cull if perpendicular (edge-on to camera)
        if (abs(dot(front, viewDir)) < 0.1) {
            visible = false;
        }
    }
    
    // 2. View-frustum culling (MORE AGGRESSIVE)
    if (visible && cullingFlags.y > 0.5) {
        // Calculate approximate midpoint using Bezier curve weights
        vec3 m = 0.25 * v0 + 0.5 * v1_new + 0.25 * v2_new;
        
        // Transform all three points to clip space
        vec4 v0_clip = camera.proj * camera.view * vec4(v0, 1.0);
        vec4 v2_clip = camera.proj * camera.view * vec4(v2_new, 1.0);
        vec4 m_clip = camera.proj * camera.view * vec4(m, 1.0);
        
        // Perspective divide to get NDC coordinates
        vec3 v0_ndc = v0_clip.xyz / v0_clip.w;
        vec3 v2_ndc = v2_clip.xyz / v2_clip.w;
        vec3 m_ndc = m_clip.xyz / m_clip.w;
        
        // SMALLER tolerance = MORE AGGRESSIVE culling (easier to see)
        float tolerance = 0.95;
        
        // Check if each point is inside the frustum
        // In Vulkan NDC: x,y in [-1, 1] and z in [0, 1]
        bool v0_visible = (v0_ndc.x >= -tolerance && v0_ndc.x <= tolerance) &&
                          (v0_ndc.y >= -tolerance && v0_ndc.y <= tolerance) &&
                          (v0_ndc.z >= 0.0 && v0_ndc.z <= 1.0);
        
        bool v2_visible = (v2_ndc.x >= -tolerance && v2_ndc.x <= tolerance) &&
                          (v2_ndc.y >= -tolerance && v2_ndc.y <= tolerance) &&
                          (v2_ndc.z >= 0.0 && v2_ndc.z <= 1.0);
        
        bool m_visible = (m_ndc.x >= -tolerance && m_ndc.x <= tolerance) &&
                         (m_ndc.y >= -tolerance && m_ndc.y <= tolerance) &&
                         (m_ndc.z >= 0.0 && m_ndc.z <= 1.0);
        
        // Cull only if ALL three points are outside the frustum
        if (!v0_visible && !v2_visible && !m_visible) {
            visible = false;
        }
    }
    
// 3. Distance culling (MORE AGGRESSIVE)
    if (visible && cullingFlags.z > 0.5) {
        vec3 camPos = (inverse(camera.view) * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
        float distance = length(v0 - camPos);
        
        // More aggressive max distance
        float maxDistance = 30.0;  // Reduced from 50.0
        
        // Immediate culling beyond max distance
        if (distance > maxDistance) {
            visible = false;
        } else {
            // Progressive culling based on distance buckets
            int numBuckets = 5;  // Reduced from 10 for more aggressive culling
            float bucketSize = maxDistance / float(numBuckets);
            int bucketIndex = int(distance / bucketSize);
            
            // Start culling from bucket 1 (not bucket 0)
            if (bucketIndex >= 1) {
                // Much more aggressive culling probability
                float cullProbability = float(bucketIndex) / float(numBuckets);
                cullProbability = cullProbability * cullProbability; // Square it for more aggressive culling
                
                float hashVal = fract(sin(dot(v0.xz, vec2(12.9898, 78.233))) * 43758.5453);
                
                if (hashVal < cullProbability) {
                    visible = false;
                }
            }
        }
    }
    
    // Write visible blade to output
    if (visible) {
        blades[index] = blade;
        uint idx = atomicAdd(numBlades.vertexCount, 1);
        culledBlades[idx] = blade;
    }
}